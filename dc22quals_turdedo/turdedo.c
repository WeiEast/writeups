/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2013 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc(void); // weak
// struct passwd *getpwnam(const char *name);
// int __cdecl setresuid(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int printf(const char *format, ...);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// time_t time(time_t *timer);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int chdir(const char *path);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// FILE *popen(const char *command, const char *modes);
// __uid_t getuid(void);
// int initgroups(const char *, __gid_t group);
// uint16_t htons(uint16_t hostshort);
// __uid_t geteuid(void);
// __gid_t getegid(void);
// int ioctl(int fd, unsigned __int32 request, ...);
// int seteuid(__uid_t uid);
// void perror(const char *s);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int setgid(__gid_t gid);
// int puts(const char *s);
// uint32_t ntohl(uint32_t netlong);
// int __gmon_start__(void); weak
// void exit(int status);
// int kill(__pid_t pid, int sig);
// int pclose(FILE *stream);
// void srand(unsigned int seed);
// char *strchr(const char *s, int c);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int pipe(int *pipedes);
// int rand(void);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int setegid(__gid_t gid);
// __pid_t fork(void);
// uint32_t htonl(uint32_t hostlong);
// uint16_t ntohs(uint16_t netshort);
// int setuid(__uid_t uid);
// int sprintf(char *s, const char *format, ...);
// int socket(int domain, int type, int protocol);
// int __cdecl setresgid(_DWORD, _DWORD); weak
// in_addr_t inet_addr(const char *cp);
// int strncmp(const char *s1, const char *s2, size_t n);
// int close(int fd);
// void *calloc(size_t nmemb, size_t size);
void sub_8048D90();
int sub_8048DF0();
int __cdecl drop_privs(char *name); // idb
signed int __cdecl drop_privs_user(int a1);
char **__cdecl lookup_error_code(int a1);
int __cdecl sub_804908F(int a1, int a2, unsigned int a3);
int __cdecl open_raw_socket_maybe(int a1, const char *a2);
signed int open_socket();
struct_frag *__cdecl lookup_ip_fragment_state_table(ip6_frag_packet_with_data *a1); // idb
int __cdecl check_for_percent_n(int a1, unsigned int a2);
int __cdecl hande_fragment(ip6_frag_packet_with_data *a1, signed int a2_frag_size, int addr); // idb
struct_ptr *__cdecl lookup_packet_in_state_table(void *a1, char s2, int a3, int a4, int a5, char a6, int a7, int a8, int a9, int a10, int a11);
int __cdecl add_to_frag_state_table(struct_frag *a1); // idb
int __cdecl remove_from_frag_state_table(void *a1);
int __cdecl add_to_state_table(struct_ptr *a1); // idb
int __cdecl remove_from_state_table(struct_ptr *a1); // idb
signed int __cdecl sendto_0(const void *a1, size_t a2, ptr_type *a3);
int __cdecl cmdprocessor(struct_ptr *connection); // idb
time_t cleanup_stale_connections();
int __cdecl udp_state_machine(udp_ip63 *packet_, struct sockaddr *addr); // idb
time_t cleanup_frag_state_table();
int main_loop(void); // weak
size_t __cdecl main(int a1, char **a2); // idb
int *__cdecl sub_804C2E0(int a1, int a2, int a3);
void sub_804C352();
int sub_804C360();
void term_proc();
// int kill(__pid_t pid, int sig);

//-------------------------------------------------------------------------
// Data declarations

char aServer[9] = "server% "; // weak
char aBye[5] = "Bye\n"; // weak
int dword_804DF14 = 4294967295; // weak
int dword_804DF1C[] = { 4294967295 }; // weak
_UNKNOWN unk_804DF20; // weak
int dword_804DF24 = 0; // weak
char **errors = &aUnableToOpenSo;
FILE *stderr; // idb
char byte_804E150; // weak
int dword_804E154; // weak
int debug; // weak
int fd; // idb
struct_frag *fragments_list;
int time2; // weak
__int16 short0; // weak
int time1; // weak
struct_ptr *state_table_head;
unsigned __int8 ipv6addr[16];
// extern _UNKNOWN _gmon_start__; weak


//----- (080489A8) --------------------------------------------------------
int init_proc()
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_8048DF0();
  return sub_804C360();
}
// 80489A8: using guessed type int init_proc(void);
// 8048BA0: using guessed type int __gmon_start__(void);

//----- (08048D60) --------------------------------------------------------
#error "8048D63: positive sp value has been found (funcsize=2)"

//----- (08048D90) --------------------------------------------------------
void sub_8048D90()
{
  int v0; // eax@2
  int i; // ebx@2

  if ( !byte_804E150 )
  {
    v0 = dword_804E154;
    for ( i = ((&unk_804DF20 - (_UNKNOWN *)dword_804DF1C) >> 2) - 1; dword_804E154 < (unsigned int)i; v0 = dword_804E154 )
    {
      dword_804E154 = v0 + 1;
      ((void (*)(void))dword_804DF1C[v0 + 1])();
    }
    byte_804E150 = 1;
  }
}
// 804DF1C: using guessed type int dword_804DF1C[];
// 804E150: using guessed type char byte_804E150;
// 804E154: using guessed type int dword_804E154;

//----- (08048DF0) --------------------------------------------------------
int sub_8048DF0()
{
  int result; // eax@1

  result = dword_804DF24;
  if ( dword_804DF24 )
    result = 0;
  return result;
}
// 804DF24: using guessed type int dword_804DF24;

//----- (08048E14) --------------------------------------------------------
int __cdecl drop_privs(char *name)
{
  int v2; // [sp+1Ch] [bp-Ch]@3

  if ( !name )
    exit(-1);
  v2 = (int)getpwnam(name);
  if ( !v2 )
    exit(-1);
  if ( drop_privs_user(v2) )
    exit(-1);
  return 0;
}

//----- (08048E75) --------------------------------------------------------
signed int __cdecl drop_privs_user(int a1)
{
  signed int result; // eax@2
  __uid_t uid; // [sp+18h] [bp-10h]@3
  __gid_t gid; // [sp+1Ch] [bp-Ch]@3

  if ( !a1 )
    return -1;
  uid = getuid();
  gid = getgid();
  if ( initgroups(*(const char **)a1, *(_DWORD *)(a1 + 12)) )
    return -1;
  if ( setresgid(*(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 12)) )
  {
    puts("setresgid failed");
    return -1;
  }
  if ( setresuid(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 8)) )
  {
    puts("setresuid failed");
    return -1;
  }
  if ( *(_DWORD *)(a1 + 12) != gid )
  {
    if ( setgid(gid) != -1 )
    {
      puts("setgid failed");
      return -1;
    }
    if ( setegid(gid) != -1 )
    {
      puts("setegid failed");
      return -1;
    }
  }
  if ( *(_DWORD *)(a1 + 8) == uid )
    goto LABEL_32;
  if ( setuid(uid) != -1 )
  {
    puts("setuid failed");
    return -1;
  }
  if ( seteuid(uid) == -1 )
  {
LABEL_32:
    if ( getgid() == *(_DWORD *)(a1 + 12) )
    {
      if ( getegid() == *(_DWORD *)(a1 + 12) )
      {
        if ( getuid() == *(_DWORD *)(a1 + 8) )
        {
          if ( geteuid() == *(_DWORD *)(a1 + 8) )
          {
            if ( chdir(*(const char **)(a1 + 20)) )
            {
              puts("chdir failed");
              result = -1;
            }
            else
            {
              result = 0;
            }
          }
          else
          {
            result = -1;
          }
        }
        else
        {
          result = -1;
        }
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    puts("seteuid failed");
    result = -1;
  }
  return result;
}
// 8048A00: using guessed type int __cdecl setresuid(_DWORD, _DWORD);
// 8048D10: using guessed type int __cdecl setresgid(_DWORD, _DWORD);

//----- (08049080) --------------------------------------------------------
char **__cdecl lookup_error_code(int a1)
{
  return (&errors)[a1];
}

//----- (0804908F) --------------------------------------------------------
int __cdecl sub_804908F(int a1, int a2, unsigned int a3)
{
  bool v3; // al@3
  bool v4; // al@6
  uint32_t v5; // eax@7
  uint16_t v6; // ax@7
  uint16_t v7; // ax@7
  int v8; // ST1C_4@7
  int i; // [sp+20h] [bp-18h]@1
  int v11; // [sp+24h] [bp-14h]@1
  int v12; // [sp+28h] [bp-10h]@1
  unsigned __int16 v13; // [sp+2Eh] [bp-Ah]@1

  v13 = 0;
  v11 = 0;
  v12 = 8;
  for ( i = a1 + 32; ; i += 2 )
  {
    v3 = v12-- != 0;
    if ( !v3 )
      break;
    v11 += *(_WORD *)i;
  }
  v12 = 8;
  for ( i = a1 + 48; ; i += 2 )
  {
    v4 = v12-- != 0;
    if ( !v4 )
      break;
    v11 += *(_WORD *)i;
  }
  v5 = htonl(a3 + 8);
  v11 += (unsigned __int16)v5;
  v11 += HIWORD(v5);
  i = (int)&i;
  v11 += 4352;
  v6 = htons(*(_WORD *)(a1 + 64));
  v11 += v6;
  v7 = htons(*(_WORD *)(a1 + 66));
  v11 += v7;
  v8 = htons(a3 + 8);
  v11 += v8;
  i = a2;
  while ( a3 > 1 )
  {
    v11 += *(_WORD *)i;
    i += 2;
    a3 -= 2;
  }
  if ( a3 )
  {
    LOBYTE(v13) = *(_BYTE *)i;
    v11 += v13;
  }
  v11 = (v11 >> 16) + (unsigned __int16)v11;
  v11 += v11 >> 16;
  return (unsigned __int16)~(_WORD)v11;
}

//----- (08049209) --------------------------------------------------------
int __cdecl open_raw_socket_maybe(int a1, const char *a2)
{
  uint16_t v2; // ax@2
  char **v3; // eax@4
  unsigned int v4; // eax@6
  char **v5; // eax@10
  in_addr_t v7; // [sp+24h] [bp-34h]@12
  int fd; // [sp+28h] [bp-30h]@2
  char s[32]; // [sp+2Ch] [bp-2Ch]@7
  int v10; // [sp+4Ch] [bp-Ch]@1

  v10 = *MK_FP(__GS__, 20);
  if ( a2 )
  {
    v7 = inet_addr(a2);
  }
  else
  {
    v2 = htons(3u);
    fd = socket(PF_PACKET, 3, v2);
    if ( fd < 0 )
    {
      if ( debug )
      {
        v3 = lookup_error_code(0);
        fprintf(stderr, (const char *)v3);
      }
      exit(-1);
    }
    v4 = 0;
    do
    {
      *(_DWORD *)&s[v4] = 0;
      v4 += 4;
    }
    while ( v4 < 0x20 );
    snprintf(s, 0x10u, "%s", a1);
    if ( ioctl(fd, SIOCGIFADDR, s) < 0 )        // SIOCGIFADDR
    {
      if ( debug )
      {
        v5 = lookup_error_code(1);
        fprintf(stderr, (const char *)v5);
      }
      exit(-1);
    }
    close(fd);
    *(_DWORD *)ipv6addr = 0;
    *(_DWORD *)&ipv6addr[4] = 0;
    *(_DWORD *)&ipv6addr[8] = 0;
    *(_DWORD *)&ipv6addr[12] = 0;
    v7 = *(_DWORD *)&s[20];
  }
  ipv6addr[0] = 0x20;
  ipv6addr[1] = 1;
  ipv6addr[2] = 0;
  ipv6addr[3] = 0;
  ipv6addr[4] = v7;
  ipv6addr[5] = (unsigned __int16)(v7 & 0xFF00) >> 8;
  ipv6addr[6] = (v7 & 0xFF0000) >> 16;
  ipv6addr[7] = BYTE3(v7);
  ipv6addr[8] = 0;
  ipv6addr[9] = 0;
  ipv6addr[10] = -14;
  ipv6addr[11] = 39;
  ipv6addr[12] = ~(_BYTE)v7;
  ipv6addr[13] = ~((unsigned __int16)(v7 & 0xFF00) >> 8);
  ipv6addr[14] = ~((v7 & 0xFF0000) >> 16);
  ipv6addr[15] = ~BYTE3(v7);
  return *MK_FP(__GS__, 20) ^ v10;
}
// 804E158: using guessed type int debug;
// 8049209: using guessed type char s[32];

//----- (0804943B) --------------------------------------------------------
signed int open_socket()
{
  signed int result; // eax@2
  int v1; // edx@6
  struct sockaddr addr; // [sp+1Ch] [bp-1Ch]@3
  int v3; // [sp+2Ch] [bp-Ch]@1

  v3 = *MK_FP(__GS__, 20);
  fd = socket(SOCK_DGRAM, 2, 0);
  if ( fd >= 0 )
  {
    *(_DWORD *)&addr.sa_data[6] = 0;
    *(_DWORD *)&addr.sa_data[10] = 0;
    addr.sa_family = 2;
    *(_DWORD *)&addr.sa_data[2] = htonl(0);
    *(_WORD *)&addr.sa_data[0] = htons(3544u);
    if ( bind(fd, &addr, 0x10u) >= 0 )
    {
      result = 0;
    }
    else
    {
      close(fd);
      result = -1;
    }
  }
  else
  {
    fwrite("socket failed\n", 1u, 0xEu, stderr);
    result = -1;
  }
  v1 = *MK_FP(__GS__, 20) ^ v3;
  return result;
}

//----- (08049534) --------------------------------------------------------
struct_frag *__cdecl lookup_ip_fragment_state_table(ip6_frag_packet_with_data *a1)
{
  struct_frag *i; // [sp+14h] [bp-14h]@1

  for ( i = fragments_list; i; i = i->next )
  {
    if ( ntohl(a1->frag_packet.ip6f_ident) == i->ip6f_ident
      && !memcmp(&a1->ip6hdr.ip6_src, &i->src_addr, 0x10u)
      && !memcmp(&a1->ip6hdr.ip6_dst, &i->dst_addr, 0x10u) )
      return i;
  }
  return 0;
}

//----- (080495CD) --------------------------------------------------------
int __cdecl check_for_percent_n(int a1, unsigned int a2)
{
  unsigned int i; // [sp+20h] [bp-28h]@1
  signed int v4; // [sp+24h] [bp-24h]@1
  char s[17]; // [sp+2Bh] [bp-1Dh]@1
  int cookie; // [sp+3Ch] [bp-Ch]@1

  cookie = *MK_FP(__GS__, 20);
  v4 = 0;
  strcpy(s, "dDiouxXfegEasc[p");
  for ( i = 0; i < a2; ++i )
  {
    if ( *(_BYTE *)(a1 + i) == '%' )
    {
      v4 = 1;
    }
    else if ( v4 && *(_BYTE *)(a1 + i) == 'n' )
    {
      *(_BYTE *)(a1 + i) = '_';
      v4 = 0;
    }
    else if ( v4 && strchr(s, *(_BYTE *)(a1 + i)) )
    {
      v4 = 0;
    }
  }
  return *MK_FP(__GS__, 20) ^ cookie;
}

//----- (0804969B) --------------------------------------------------------
int __cdecl hande_fragment(ip6_frag_packet_with_data *a1, signed int a2_frag_size, int addr)
{
  int result; // eax@2
  char **v4; // eax@3
  uint16_t v5; // ax@5 MAPDST
  __int16 v6; // ST2E_2@6
  udp_ip62 *v7; // ebx@8
  uint16_t v8; // ax@10
  uint16_t v9; // ax@11
  char **v10; // eax@16
  in6_addr *v11; // eax@19
  in6_addr *v12; // eax@19
  uint16_t v13; // ax@20
  uint16_t packet_len; // ax@21
  udp_ip62 *v15; // ebx@21
  char *dest; // [sp+18h] [bp-20h]@6
  udp_ip62 *frag_data; // [sp+18h] [bp-20h]@18
  struct_frag *frag; // [sp+20h] [bp-18h]@17 MAPDST
  uint16_t offset_size; // [sp+2Ah] [bp-Eh]@17
  uint16_t more_frags_to_come; // [sp+2Ch] [bp-Ch]@6
  uint16_t more_frags_to_comea; // [sp+2Ch] [bp-Ch]@17
  __int16 v24; // [sp+2Eh] [bp-Ah]@7
  __int16 frag_len; // [sp+2Eh] [bp-Ah]@18

  if ( a2_frag_size > 0x2F )
  {
    frag = lookup_ip_fragment_state_table(a1);
    if ( frag )
    {
      v5 = ntohs(a1->frag_packet.ip6f_offlg & 0xF8FF);
      result = v5 + ntohs(a1->ip6hdr.ip6_un1_plen) - 8;
      if ( result > 0xFFFF )                    // why you signed?
        return result;
      more_frags_to_come = ntohs(a1->frag_packet.ip6f_offlg & 0x100);
      v6 = frag->len;
      dest = (char *)frag->frag_data;
      if ( v5 + ntohs(a1->ip6hdr.ip6_un1_plen) - 8 > frag->len - 40 )
      {
        v24 = v5 + ntohs(a1->ip6hdr.ip6_un1_plen) + 0x20;
        result = (int)calloc(1u, (unsigned __int16)v24);
        dest = (char *)result;
        if ( !result )
          return result;
        memcpy((void *)result, frag->frag_data, frag->len);// copy current contents into buffer
        free(frag->frag_data);
        frag->frag_data = (udp_ip62 *)dest;
        frag->len = v24;
        v7 = frag->frag_data;
        v7->hdr.ip6_un1_plen = htons(v24 - 40);
      }
      if ( ntohs(a1->ip6hdr.ip6_un1_plen) > 0x10u )
      {
        v8 = ntohs(a1->ip6hdr.ip6_un1_plen);
        check_for_percent_n((int)a1->data, v8 - 8);
      }
      v9 = ntohs(a1->ip6hdr.ip6_un1_plen);
      memcpy(&dest[v5 + 40], a1->data, v9 - 8); // copy new contents into buffer
      if ( more_frags_to_come )
      {
        result = time(0);
        frag->time = result;
      }
      else
      {
        udp_state_machine((udp_ip63 *)dest, (struct sockaddr *)addr);
        free(dest);
        result = remove_from_frag_state_table(frag);
      }
    }
    else if ( a1->frag_packet.ip6f_nxt == IPPROTO_UDP )
    {
      offset_size = ntohs(a1->frag_packet.ip6f_offlg & 0xF8FF);
      more_frags_to_comea = ntohs(a1->frag_packet.ip6f_offlg & 0x100);
      result = (int)calloc(1u, 0x34u);
      frag = (struct_frag *)result;
      if ( result )
      {
        frag_len = offset_size + ntohs(a1->ip6hdr.ip6_un1_plen) + 0x20;
        result = (int)calloc(1u, (unsigned __int16)frag_len);
        frag_data = (udp_ip62 *)result;
        if ( result )
        {
          frag->ip6f_ident = ntohl(a1->frag_packet.ip6f_ident);
          v11 = &frag->src_addr;
          v11->__u6_addr32[0] = a1->ip6hdr.ip6_src.__u6_addr32[0];
          v11->__u6_addr32[1] = a1->ip6hdr.ip6_src.__u6_addr32[1];
          v11->__u6_addr32[2] = a1->ip6hdr.ip6_src.__u6_addr32[2];
          v11->__u6_addr32[3] = a1->ip6hdr.ip6_src.__u6_addr32[3];
          v12 = &frag->dst_addr;
          v12->__u6_addr32[0] = a1->ip6hdr.ip6_dst.__u6_addr32[0];
          v12->__u6_addr32[1] = a1->ip6hdr.ip6_dst.__u6_addr32[1];
          v12->__u6_addr32[2] = a1->ip6hdr.ip6_dst.__u6_addr32[2];
          v12->__u6_addr32[3] = a1->ip6hdr.ip6_dst.__u6_addr32[3];
          frag->frag_data = frag_data;
          frag_data->hdr.ip6_un1_flow = a1->ip6hdr.ip6_un1_flow;
          *(_DWORD *)&frag_data->hdr.ip6_un1_plen = *(_DWORD *)&a1->ip6hdr.ip6_un1_plen;
          frag_data->hdr.ip6_src.__u6_addr32[0] = a1->ip6hdr.ip6_src.__u6_addr32[0];
          frag_data->hdr.ip6_src.__u6_addr32[1] = a1->ip6hdr.ip6_src.__u6_addr32[1];
          frag_data->hdr.ip6_src.__u6_addr32[2] = a1->ip6hdr.ip6_src.__u6_addr32[2];
          frag_data->hdr.ip6_src.__u6_addr32[3] = a1->ip6hdr.ip6_src.__u6_addr32[3];
          frag_data->hdr.ip6_dst.__u6_addr32[0] = a1->ip6hdr.ip6_dst.__u6_addr32[0];
          frag_data->hdr.ip6_dst.__u6_addr32[1] = a1->ip6hdr.ip6_dst.__u6_addr32[1];
          frag_data->hdr.ip6_dst.__u6_addr32[2] = a1->ip6hdr.ip6_dst.__u6_addr32[2];
          frag_data->hdr.ip6_dst.__u6_addr32[3] = a1->ip6hdr.ip6_dst.__u6_addr32[3];
          if ( ntohs(a1->ip6hdr.ip6_un1_plen) > 0x10u )
          {
            v13 = ntohs(a1->ip6hdr.ip6_un1_plen);
            check_for_percent_n((int)&a1->data[8], v13 - 16);
          }
          packet_len = ntohs(a1->ip6hdr.ip6_un1_plen);
          memcpy((char *)&frag_data->udphd + offset_size, a1->data, packet_len - 8);
          v15 = frag->frag_data;
          v15->hdr.ip6_un1_plen = htons(frag_len - 40);
          frag->len = frag_len;
          frag->time = time(0);
          result = add_to_frag_state_table(frag);
          if ( !more_frags_to_comea )
          {
            udp_state_machine((udp_ip63 *)frag_data, (struct sockaddr *)addr);
            free(frag_data);
            result = remove_from_frag_state_table(frag);
          }
        }
      }
    }
    else
    {
      result = debug;
      if ( debug )
      {
        v10 = lookup_error_code(3);             // not a udp fragment
        result = fprintf(stderr, (const char *)v10);
      }
    }
  }
  else
  {
    result = debug;
    if ( debug )
    {
      v4 = lookup_error_code(2);                // fragment not long enough
      result = fprintf(stderr, (const char *)v4);
    }
  }
  return result;
}
// 804E158: using guessed type int debug;

//----- (08049B95) --------------------------------------------------------
struct_ptr *__cdecl lookup_packet_in_state_table(void *a1, char s2, int a3, int a4, int a5, char a6, int a7, int a8, int a9, int a10, int a11)
{
  __int16 v12; // [sp+18h] [bp-20h]@1
  __int16 v13; // [sp+1Ch] [bp-1Ch]@1
  struct_ptr *i; // [sp+2Ch] [bp-Ch]@1

  v13 = a10;
  v12 = a11;
  for ( i = state_table_head; i; i = i->next )
  {
    if ( !memcmp(&i->ip6_src_addr, &s2, 0x10u)
      && !memcmp(&i->ip6_dst_addr, &a6, 0x10u)
      && !memcmp(&i->tunnel_sockaddr, a1, 0x10u)
      && i->udp_sport == v13
      && i->udp_dport == v12 )
      return i;
  }
  return 0;
}

//----- (08049C52) --------------------------------------------------------
int __cdecl add_to_frag_state_table(struct_frag *a1)
{
  int result; // eax@2

  if ( fragments_list )
  {
    a1->next = fragments_list;
    fragments_list = a1;
    result = 0;
  }
  else
  {
    fragments_list = a1;
    a1->next = 0;
    result = 0;
  }
  return result;
}

//----- (08049C9A) --------------------------------------------------------
int __cdecl remove_from_frag_state_table(void *a1)
{
  int result; // eax@4
  struct_frag *ptr; // [sp+18h] [bp-10h]@1
  struct_frag *v3; // [sp+1Ch] [bp-Ch]@1

  ptr = fragments_list;
  v3 = fragments_list;
  while ( 1 )
  {
    if ( !ptr )
      return 0;
    if ( ptr == a1 )
      break;
    v3 = ptr;
    ptr = ptr->next;
  }
  if ( v3 == ptr )
  {
    fragments_list = ptr->next;
    free(ptr);
    result = 0;
  }
  else
  {
    v3->next = ptr->next;
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08049D48) --------------------------------------------------------
int __cdecl add_to_state_table(struct_ptr *a1)
{
  int result; // eax@2

  if ( state_table_head )
  {
    a1->next = state_table_head;
    state_table_head = a1;
    result = 0;
  }
  else
  {
    state_table_head = a1;
    a1->next = 0;
    result = 0;
  }
  return result;
}

//----- (08049D90) --------------------------------------------------------
int __cdecl remove_from_state_table(struct_ptr *a1)
{
  int result; // eax@4
  struct_ptr *ptr; // [sp+18h] [bp-10h]@1
  struct_ptr *tail; // [sp+1Ch] [bp-Ch]@1

  ptr = state_table_head;
  tail = state_table_head;
  while ( 1 )
  {
    if ( !ptr )
      return 0;
    if ( ptr == a1 )
      break;
    tail = ptr;
    ptr = ptr->next;
  }
  if ( tail == ptr )
  {
    state_table_head = ptr->next;
    free(ptr);
    result = 0;
  }
  else
  {
    tail->next = ptr->next;
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08049E0F) --------------------------------------------------------
signed int __cdecl sendto_0(const void *a1, size_t a2, ptr_type *a3)
{
  signed int result; // eax@2
  int v4; // ST34_4@6
  uint32_t v5; // ST38_4@6
  int v6; // ST3C_4@6
  int v7; // ST40_4@6
  int v8; // ST34_4@7
  uint32_t v9; // eax@7
  int v10; // ST34_4@9
  uint32_t v11; // eax@9
  uint32_t v12; // eax@9
  int v13; // ST3C_4@10
  uint32_t v14; // ST40_4@10
  ssize_t v15; // eax@6
  char **v16; // eax@13
  int v17; // edx@18
  size_t v18; // [sp+44h] [bp-634h]@3
  size_t n; // [sp+48h] [bp-630h]@6
  signed int v20; // [sp+4Ch] [bp-62Ch]@3
  signed int v21; // [sp+50h] [bp-628h]@3
  size_t v22; // [sp+54h] [bp-624h]@6
  uint32_t buf; // [sp+58h] [bp-620h]@3
  int v24; // [sp+5Ch] [bp-61Ch]@6
  int v25; // [sp+60h] [bp-618h]@6
  int v26; // [sp+64h] [bp-614h]@6
  int v27; // [sp+68h] [bp-610h]@6
  int v28; // [sp+6Ch] [bp-60Ch]@6
  __int64 v29; // [sp+70h] [bp-608h]@6
  int v30; // [sp+78h] [bp-600h]@6
  int v31; // [sp+7Ch] [bp-5FCh]@6
  int v32; // [sp+80h] [bp-5F8h]@6
  uint32_t v33; // [sp+84h] [bp-5F4h]@6
  int v34; // [sp+88h] [bp-5F0h]@6
  int v35; // [sp+8Ch] [bp-5ECh]@6
  int v36; // [sp+90h] [bp-5E8h]@6
  uint32_t v37; // [sp+634h] [bp-44h]@3
  uint16_t v38; // [sp+638h] [bp-40h]@6
  char v39; // [sp+63Ah] [bp-3Eh]@6
  char v40; // [sp+63Bh] [bp-3Dh]@4
  int v41; // [sp+63Ch] [bp-3Ch]@4
  int v42; // [sp+640h] [bp-38h]@4
  int v43; // [sp+644h] [bp-34h]@4
  int v44; // [sp+648h] [bp-30h]@4
  __int64 v45; // [sp+64Ch] [bp-2Ch]@4
  int v46; // [sp+654h] [bp-24h]@4
  int v47; // [sp+658h] [bp-20h]@4
  int v48; // [sp+66Ch] [bp-Ch]@1

  v48 = *MK_FP(__GS__, 20);
  if ( a2 <= 0xFFFF )
  {
    memset(&v37, 0, 0x28u);
    memset(&buf, 0, 0x5DCu);
    v21 = 0;
    v18 = 0;
    v20 = 1;
    while ( 1 )
    {
      if ( v18 >= a2 )
      {
        result = v18;
        goto LABEL_18;
      }
      v37 = htonl(0x60000000u);
      v40 = -1;
      v41 = *((_DWORD *)a3 + 12);
      v42 = *((_DWORD *)a3 + 13);
      v43 = *((_DWORD *)a3 + 14);
      v44 = *((_DWORD *)a3 + 15);
      v45 = *((_QWORD *)a3 + 4);
      v46 = *((_DWORD *)a3 + 10);
      v47 = *((_DWORD *)a3 + 11);
      if ( a2 - v18 <= 0x588 )
      {
        if ( v21 )
        {
          n = a2 - v18;
          v38 = htons(a2 - v18 + 8);
          v39 = 44;
          LOWORD(v10) = 17;
          HIWORD(v10) = htons(8 * ((v18 + 8) >> 3));
          v11 = *((_DWORD *)a3 + 17);
          *((_DWORD *)a3 + 17) = v11 + 1;
          v12 = htonl(v11);
          buf = v37;
          v24 = *(_DWORD *)&v38;
          v25 = v41;
          v26 = v42;
          v27 = v43;
          v28 = v44;
          v29 = v45;
          v30 = v46;
          v31 = v47;
          v32 = v10;
          v33 = v12;
          memcpy(&v34, (char *)a1 + v18, a2 - v18);
          v22 = a2 - v18 + 48;
          v15 = sendto(fd, &buf, v22, 0, (const struct sockaddr *)((char *)a3 + 12), 0x10u);
        }
        else
        {
          n = a2;
          v38 = htons(a2 + 8);
          v39 = 17;
          LOWORD(v13) = htons(*((_WORD *)a3 + 33));
          HIWORD(v13) = htons(*((_WORD *)a3 + 32));
          LOWORD(v14) = htons(a2 + 8);
          HIWORD(v14) = sub_804908F((int)a3, (int)a1, a2);
          buf = v37;
          v24 = *(_DWORD *)&v38;
          v25 = v41;
          v26 = v42;
          v27 = v43;
          v28 = v44;
          v29 = v45;
          v30 = v46;
          v31 = v47;
          v32 = v13;
          v33 = v14;
          memcpy(&v34, a1, a2);
          v22 = a2 + 48;
          v15 = sendto(fd, &buf, a2 + 48, 0, (const struct sockaddr *)((char *)a3 + 12), 0x10u);
        }
      }
      else
      {
        v21 = 1;
        if ( v20 )
        {
          n = 1416;
          v38 = htons(0x598u);
          v39 = 44;
          LOWORD(v4) = 17;
          HIWORD(v4) = htons(1u);
          v5 = htonl(*((_DWORD *)a3 + 17));
          LOWORD(v6) = htons(*((_WORD *)a3 + 33));
          HIWORD(v6) = htons(*((_WORD *)a3 + 32));
          LOWORD(v7) = htons(a2 + 8);
          HIWORD(v7) = sub_804908F((int)a3, (int)a1, a2);
          v20 = 0;
          buf = v37;
          v24 = *(_DWORD *)&v38;
          v25 = v41;
          v26 = v42;
          v27 = v43;
          v28 = v44;
          v29 = v45;
          v30 = v46;
          v31 = v47;
          v32 = v4;
          v33 = v5;
          v34 = v6;
          v35 = v7;
          memcpy(&v36, (char *)a1 + v18, 0x588u);
          v22 = 1472;
          v15 = sendto(fd, &buf, 0x5C0u, 0, (const struct sockaddr *)((char *)a3 + 12), 0x10u);
        }
        else
        {
          n = 1424;
          v38 = htons(0x598u);
          v39 = 44;
          LOWORD(v8) = 17;
          HIWORD(v8) = htons(8 * ((v18 + 8) >> 3) | 1);
          v9 = htonl(*((_DWORD *)a3 + 17));
          buf = v37;
          v24 = *(_DWORD *)&v38;
          v25 = v41;
          v26 = v42;
          v27 = v43;
          v28 = v44;
          v29 = v45;
          v30 = v46;
          v31 = v47;
          v32 = v8;
          v33 = v9;
          memcpy(&v34, (char *)a1 + v18, 0x590u);
          v22 = 1472;
          v15 = sendto(fd, &buf, 1472u, 0, (const struct sockaddr *)((char *)a3 + 12), 0x10u);
        }
      }
      if ( v15 != v22 )
        break;
      v18 += n;
    }
    perror("sendto");
    if ( debug )
    {
      v16 = lookup_error_code(5);
      fprintf(stderr, (const char *)v16);
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
LABEL_18:
  v17 = *MK_FP(__GS__, 20) ^ v48;
  return result;
}
// 804E158: using guessed type int debug;

//----- (0804A569) --------------------------------------------------------
int __cdecl cmdprocessor(struct_ptr *connection)
{
  bool v1; // cf@4
  bool v2; // zf@4
  signed int v3; // ecx@4
  char *v4; // esi@4
  int v5; // edi@4
  int v6; // eax@7
  bool v7; // cf@7
  bool v8; // zf@7
  signed int v9; // ecx@10
  char *v10; // esi@10
  int v11; // edi@10
  int v12; // eax@13
  bool v13; // cf@13
  bool v14; // zf@13
  char *v15; // eax@22
  signed int v16; // ecx@25
  char *v17; // esi@25
  int v18; // edi@25
  int v19; // eax@28
  bool v20; // cf@28
  bool v21; // zf@28
  char *v22; // eax@32
  signed int v23; // ecx@35
  char *v24; // esi@35
  char v25[4]; // edi@35
  int v26; // eax@38
  bool v27; // cf@38
  bool v28; // zf@38
  char *v29; // eax@47
  signed int v30; // ecx@50
  char *v31; // esi@50
  int v32; // edi@50
  int v33; // eax@53
  bool v34; // cf@53
  bool v35; // zf@53
  char *v36; // eax@57
  signed int v37; // ecx@60
  char *v38; // esi@60
  int v39; // edi@60
  int v40; // eax@63
  bool v41; // cf@63
  bool v42; // zf@63
  signed int v43; // ecx@66
  char *v44; // esi@66
  int v45; // edi@66
  int v46; // eax@69
  bool v47; // cf@69
  bool v48; // zf@69
  char *v49; // eax@73
  signed int v50; // ecx@76
  char *v51; // esi@76
  int v52; // edi@76
  int v53; // eax@79
  bool v54; // cf@79
  bool v55; // zf@79
  signed int v56; // ecx@82
  char *v57; // esi@82
  int v58; // edi@82
  unsigned int i; // [sp+20h] [bp-12778h]@14
  unsigned int j; // [sp+20h] [bp-12778h]@39
  ssize_t v62; // [sp+28h] [bp-12770h]@91
  FILE *stream; // [sp+34h] [bp-12764h]@19
  FILE *streama; // [sp+34h] [bp-12764h]@29
  FILE *streamb; // [sp+34h] [bp-12764h]@44
  FILE *streamc; // [sp+34h] [bp-12764h]@54
  FILE *streamd; // [sp+34h] [bp-12764h]@70
  char s[65536]; // [sp+38h] [bp-12760h]@1
  char ptr[10000]; // [sp+10038h] [bp-2760h]@4
  char lschars[40]; // [sp+12748h] [bp-50h]@1
  char unamechars[11]; // [sp+12771h] [bp-27h]@1
  int cookie; // [sp+1277Ch] [bp-1Ch]@1

  cookie = *MK_FP(__GS__, 20);
  strcpy(lschars, "abcdefghijklmnopqrstuvwxyz0123456789/-. ");
  strcpy(unamechars, "-asnrvmpio");
  memset(s, 0, 0xFFFFu);
  while ( 1 )
  {
    while ( 1 )
    {
      v62 = read(connection->child_pipe[0], s, 0xFFFFu);
      if ( v62 <= 0 )
        exit(0);
      if ( v62 > 7 )
        break;
      memset(s, 0, 0x10000u);
    }
    memset(ptr, 0, 0x2710u);
    v3 = 5;
    v4 = &s[8];
    v5 = (int)"help";
    do
    {
      if ( !v3 )
        break;
      v1 = (unsigned __int8)*v4 < *(_BYTE *)v5;
      v2 = *v4++ == *(_BYTE *)v5++;
      --v3;
    }
    while ( v2 );
    v6 = (char)((!v1 && !v2) - v1);
    v7 = 0;
    v8 = v6 == 0;
    if ( !v6 )
    {
      sprintf(ptr, "Available commands:\nuname\nls\ncat\npwd\necho\nexit\nserver%% ");
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v9 = 6;
    v10 = &s[8];
    v11 = (int)"uname ";
    do
    {
      if ( !v9 )
        break;
      v7 = (unsigned __int8)*v10 < *(_BYTE *)v11;
      v8 = *v10++ == *(_BYTE *)v11++;
      --v9;
    }
    while ( v8 );
    v12 = (char)((!v7 && !v8) - v7);
    v13 = 0;
    v14 = v12 == 0;
    if ( !v12 )
    {
      for ( i = 6; i < strlen(&s[8]); ++i )     // check for command injection via uname
      {
        if ( !strchr(unamechars, (unsigned __int8)s[i + 8]) )
          memset(s, 0, 0x10000u);
      }
      stream = popen(&s[8], "r");
      if ( stream )
      {
        fread(ptr, 1u, 0x270Fu, stream);
        pclose(stream);
      }
      if ( strlen(ptr) <= 0x2706 )
      {
        v15 = &ptr[strlen(ptr)];
        *(_DWORD *)v15 = *(_DWORD *)"server% ";
        *((_DWORD *)v15 + 1) = *(_DWORD *)"er% ";
        v15[8] = aServer[8];
      }
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v16 = 6;
    v17 = &s[8];
    v18 = (int)"uname";
    do
    {
      if ( !v16 )
        break;
      v13 = (unsigned __int8)*v17 < *(_BYTE *)v18;
      v14 = *v17++ == *(_BYTE *)v18++;
      --v16;
    }
    while ( v14 );
    v19 = (char)((!v13 && !v14) - v13);
    v20 = 0;
    v21 = v19 == 0;
    if ( !v19 )
    {
      streama = popen("uname", "r");
      if ( streama )
      {
        fread(ptr, 1u, 0x270Fu, streama);
        pclose(streama);
      }
      if ( strlen(ptr) <= 0x2706 )
      {
        v22 = &ptr[strlen(ptr)];
        *(_DWORD *)v22 = *(_DWORD *)"server% ";
        *((_DWORD *)v22 + 1) = *(_DWORD *)"er% ";
        v22[8] = aServer[8];
      }
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v23 = 3;
    v24 = &s[8];
    *(_DWORD *)v25 = "ls ";
    do
    {
      if ( !v23 )
        break;
      v20 = (unsigned __int8)*v24 < **(_BYTE **)v25;
      v21 = *v24++ == **(_BYTE **)v25;
      ++*(_DWORD *)v25;
      --v23;
    }
    while ( v21 );
    v26 = (char)((!v20 && !v21) - v20);
    v27 = 0;
    v28 = v26 == 0;
    if ( !v26 )
    {
      for ( j = 3; j < strlen(&s[8]); ++j )
      {
        if ( !strchr(lschars, (unsigned __int8)s[j + 8]) )
          memset(s, 0, 0x10000u);
      }
      streamb = popen(&s[8], "r");
      if ( streamb )
      {
        fread(ptr, 1u, 0x270Fu, streamb);
        pclose(streamb);
      }
      if ( strlen(ptr) <= 0x2706 )
      {
        v29 = &ptr[strlen(ptr)];
        *(_DWORD *)v29 = *(_DWORD *)"server% ";
        *((_DWORD *)v29 + 1) = *(_DWORD *)"er% ";
        v29[8] = aServer[8];
      }
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v30 = 3;
    v31 = &s[8];
    v32 = (int)"ls";
    do
    {
      if ( !v30 )
        break;
      v27 = (unsigned __int8)*v31 < *(_BYTE *)v32;
      v28 = *v31++ == *(_BYTE *)v32++;
      --v30;
    }
    while ( v28 );
    v33 = (char)((!v27 && !v28) - v27);
    v34 = 0;
    v35 = v33 == 0;
    if ( !v33 )
    {
      streamc = popen("ls", "r");
      if ( streamc )
      {
        fread(ptr, 1u, 0x270Fu, streamc);
        pclose(streamc);
      }
      if ( strlen(ptr) <= 0x2706 )
      {
        v36 = &ptr[strlen(ptr)];
        *(_DWORD *)v36 = *(_DWORD *)"server% ";
        *((_DWORD *)v36 + 1) = *(_DWORD *)"er% ";
        v36[8] = aServer[8];
      }
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v37 = 4;
    v38 = &s[8];
    v39 = (int)"cat ";
    do
    {
      if ( !v37 )
        break;
      v34 = (unsigned __int8)*v38 < *(_BYTE *)v39;
      v35 = *v38++ == *(_BYTE *)v39++;
      --v37;
    }
    while ( v35 );
    v40 = (char)((!v34 && !v35) - v34);
    v41 = 0;
    v42 = v40 == 0;
    if ( !v40 )
    {
      sprintf(ptr, "Yeah, right...\nserver%% ");
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v43 = 3;
    v44 = &s[8];
    v45 = (int)"pwd";
    do
    {
      if ( !v43 )
        break;
      v41 = (unsigned __int8)*v44 < *(_BYTE *)v45;
      v42 = *v44++ == *(_BYTE *)v45++;
      --v43;
    }
    while ( v42 );
    v46 = (char)((!v41 && !v42) - v41);
    v47 = 0;
    v48 = v46 == 0;
    if ( !v46 )
    {
      streamd = popen("pwd", "r");
      if ( streamd )
      {
        fread(ptr, 1u, 0x270Fu, streamd);
        pclose(streamd);
      }
      if ( strlen(ptr) <= 0x2706 )
      {
        v49 = &ptr[strlen(ptr)];
        *(_DWORD *)v49 = *(_DWORD *)"server% ";
        *((_DWORD *)v49 + 1) = *(_DWORD *)"er% ";
        v49[8] = aServer[8];
      }
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
      goto LABEL_90;
    }
    v50 = 4;
    v51 = &s[8];
    v52 = (int)"exit";
    do
    {
      if ( !v50 )
        break;
      v47 = (unsigned __int8)*v51 < *(_BYTE *)v52;
      v48 = *v51++ == *(_BYTE *)v52++;
      --v50;
    }
    while ( v48 );
    v53 = (char)((!v47 && !v48) - v47);
    v54 = 0;
    v55 = v53 == 0;
    if ( !v53 )
      break;
    v56 = 5;
    v57 = &s[8];
    v58 = (int)"echo ";
    do
    {
      if ( !v56 )
        break;
      v54 = (unsigned __int8)*v57 < *(_BYTE *)v58;
      v55 = *v57++ == *(_BYTE *)v58++;
      --v56;
    }
    while ( v55 );
    if ( (!v54 && !v55) == v54 )
    {
      snprintf(ptr, 9999u, &s[13]);
      if ( sendto_0(ptr, 0x2710u, (ptr_type *)connection) != 10000 )
        exit(0);
    }
    else
    {
      sprintf(ptr, "Invalid command\nserver%% ");
      if ( sendto_0(ptr, strlen(ptr), (ptr_type *)connection) != strlen(ptr) )
        exit(0);
    }
LABEL_90:
    memset(s, 0, 0x10000u);
  }
  *(_DWORD *)ptr = *(_DWORD *)"Bye\n";
  ptr[4] = aBye[4];
  if ( sendto_0(ptr, 4u, (ptr_type *)connection) != 4 )
    exit(0);
  return *MK_FP(__GS__, 20) ^ cookie;
}
// 804A569: using guessed type char ptr[10000];

//----- (0804B2B1) --------------------------------------------------------
time_t cleanup_stale_connections()
{
  time_t v0; // edx@1
  time_t result; // eax@1
  time_t v2; // ebx@4
  char **v3; // eax@6
  time_t v4; // ebx@10
  char **v5; // eax@12
  int stat_loc; // [sp+10h] [bp-18h]@9
  struct_ptr *v7; // [sp+14h] [bp-14h]@2
  struct_ptr *v8; // [sp+18h] [bp-10h]@7
  int v9; // [sp+1Ch] [bp-Ch]@9

  v0 = time(0) - 1;
  result = time1;
  if ( v0 > time1 )
  {
    v7 = state_table_head;
    while ( v7 )
    {
      if ( LOBYTE(v7->state) == 3 )
      {
        v9 = waitpid(v7->child_process, &stat_loc, 1);
        if ( v9 )
        {
          v8 = v7->next;
          close(v7->child_pipe[1]);
          remove_from_state_table(v7);
          v7 = v8;
        }
        else
        {
          v4 = v7->time;
          if ( v4 >= time(0) - 10 )
          {
            v7 = v7->next;
          }
          else
          {
            if ( debug )
            {
              v5 = lookup_error_code(18);       // removing idle child
              fprintf(stderr, (const char *)v5);
            }
            v8 = v7->next;
            close(v7->child_pipe[1]);
            kill(v7->child_process, 9);
            remove_from_state_table(v7);
            v7 = v8;
          }
        }
      }
      else
      {
        v2 = v7->time;
        if ( v2 >= time(0) - 3 )
        {
          v7 = v7->next;
        }
        else
        {
          if ( debug )
          {
            v3 = lookup_error_code(6);          // removing old child
            fprintf(stderr, (const char *)v3);
          }
          v8 = v7->next;
          remove_from_state_table(v7);
          v7 = v8;
        }
      }
    }
    result = time(0);
    time1 = result;
  }
  return result;
}
// 804E158: using guessed type int debug;
// 804E16C: using guessed type int time1;

//----- (0804B45B) --------------------------------------------------------
int __cdecl udp_state_machine(udp_ip63 *packet_, struct sockaddr *addr)
{
  char **v2; // eax@3
  char **v3; // eax@6
  uint16_t v4; // bx@7
  int v5; // esi@9
  int v6; // ebx@9
  char **v7; // eax@9
  int udp_sport; // ebx@10
  uint16_t udp_dport; // ax@10
  uint16_t v11; // ax@25
  uint16_t packet_len; // ax@28 MAPDST
  in6_addr *v13; // edx@34
  in6_addr *v14; // eax@34
  in6_addr *v15; // edx@34
  in6_addr *v16; // eax@34
  int pipedes[2]; // [sp+44h] [bp-A4h]@18
  udphdr *udphdr; // [sp+58h] [bp-90h]@4
  char *udp_data; // [sp+5Ch] [bp-8Ch]@4
  struct_ptr *ptr; // [sp+60h] [bp-88h]@10
  int write_len; // [sp+64h] [bp-84h]@24
  char s[100]; // [sp+68h] [bp-80h]@12
  int v25; // [sp+CCh] [bp-1Ch]@1

  v25 = *MK_FP(__GS__, 20);
  cleanup_stale_connections();
  if ( ntohs(packet_->hdr.ip6_un1_plen) > 7u )
  {
    udphdr = &packet_->udphd;
    udp_data = (char *)packet_->data;
    if ( ntohs(packet_->udphd.uh_dport) == 3544 )
    {
      v4 = htons(packet_->hdr.ip6_un1_plen);
      if ( v4 == ntohs(udphdr->uh_ulen) )
      {
        udp_sport = ntohs(udphdr->uh_dport);
        udp_dport = ntohs(udphdr->uh_sport);
        ptr = lookup_packet_in_state_table(
                addr,
                (char)packet_->hdr.ip6_src.__u6_addr32[0],
                (int)packet_->hdr.ip6_src.__u6_addr32[1],
                (int)packet_->hdr.ip6_src.__u6_addr32[2],
                (int)packet_->hdr.ip6_src.__u6_addr32[3],
                (char)packet_->hdr.ip6_dst.__u6_addr32[0],
                (int)packet_->hdr.ip6_dst.__u6_addr32[1],
                (int)packet_->hdr.ip6_dst.__u6_addr32[2],
                (int)packet_->hdr.ip6_dst.__u6_addr32[3],
                udp_dport,
                udp_sport);
        if ( ptr )
        {
          switch ( LOBYTE(ptr->state) )
          {
            case SYNACK:
              snprintf(s, 0xEu, "ACK%d", ptr->rand_value);
              if ( ntohs(packet_->hdr.ip6_un1_plen) == strlen(s) + 8 )
              {
                if ( !strncmp(udp_data, s, strlen(s)) )
                {
                  LOBYTE(ptr->state) = 2;
                  snprintf(s, 0x63u, "server%% ");
                  if ( sendto_0(s, strlen(s), (ptr_type *)ptr) != strlen(s) )
                    remove_from_state_table(ptr);
                }
                else
                {
                  remove_from_state_table(ptr);
                }
              }
              break;
            case ACK:
              if ( !pipe(pipedes) )
              {
                ptr->child_process = fork();
                if ( ptr->child_process == -1 )
                {
                  free(ptr);
                }
                else
                {
                  if ( !ptr->child_process )
                  {
                    ptr->child_pipe[0] = pipedes[0];
                    close(pipedes[1]);
                    cmdprocessor(ptr);
                    exit(0);
                  }
                  ptr->child_pipe[1] = pipedes[1];
                  close(pipedes[0]);
                  LOBYTE(ptr->state) = 3;
                  ptr->time = time(0);
                  packet_len = ntohs(packet_->hdr.ip6_un1_plen);
                  write_len = write(ptr->child_pipe[1], &packet_->udphd, packet_len);
                  if ( write_len == -1 || (v11 = ntohs(packet_->hdr.ip6_un1_plen), v11 != write_len) )
                  {
                    close(ptr->child_pipe[1]);
                    kill(ptr->child_process, 9);
                    remove_from_state_table(ptr);
                  }
                }
              }
              break;
            case ESTABLISHED:
              packet_len = ntohs(packet_->hdr.ip6_un1_plen);
              write_len = write(ptr->child_pipe[1], &packet_->udphd, packet_len);
              ptr->time = time(0);
              if ( write_len == -1 || ntohs(packet_->hdr.ip6_un1_plen) != write_len )
              {
                close(ptr->child_pipe[1]);
                kill(ptr->child_process, 9);
                remove_from_state_table(ptr);
              }
              break;
          }
        }
        else if ( ntohs(packet_->hdr.ip6_un1_plen) == 11 && !strncmp(udp_data, "SYN", 3u) )
        {
          ptr = (struct_ptr *)calloc(1u, 0x54u);
          if ( ptr )
          {
            v13 = &packet_->hdr.ip6_src;
            v14 = (in6_addr *)&ptr->ip6_src_addr;
            v14->__u6_addr32[0] = packet_->hdr.ip6_src.__u6_addr32[0];
            v14->__u6_addr32[1] = v13->__u6_addr32[1];
            v14->__u6_addr32[2] = v13->__u6_addr32[2];
            v14->__u6_addr32[3] = v13->__u6_addr32[3];
            v15 = &packet_->hdr.ip6_dst;
            v16 = (in6_addr *)&ptr->ip6_dst_addr;
            v16->__u6_addr32[0] = packet_->hdr.ip6_dst.__u6_addr32[0];
            v16->__u6_addr32[1] = v15->__u6_addr32[1];
            v16->__u6_addr32[2] = v15->__u6_addr32[2];
            v16->__u6_addr32[3] = v15->__u6_addr32[3];
            ptr->tunnel_sockaddr = *addr;
            ptr->udp_sport = ntohs(udphdr->uh_sport);
            ptr->udp_dport = ntohs(udphdr->uh_dport);
            ptr->rand_value = rand() / 2;
            snprintf(s, 0x11u, "SYNACK%d", ptr->rand_value);
            if ( sendto_0(s, strlen(s), (ptr_type *)ptr) == strlen(s) )
            {
              LOBYTE(ptr->state) = SYNACK;
              ptr->time = time(0);
              if ( add_to_state_table(ptr) )
                free(ptr);
            }
            else
            {
              free(ptr);
            }
          }
        }
      }
      else if ( debug )
      {
        v5 = ntohs(udphdr->uh_ulen);
        v6 = htons(packet_->hdr.ip6_un1_plen);
        v7 = lookup_error_code(9);
        fprintf(stderr, (const char *)v7, v6, v5);
      }
    }
    else if ( debug )
    {
      v3 = lookup_error_code(8);
      fprintf(stderr, (const char *)v3);
    }
  }
  else if ( debug )
  {
    v2 = lookup_error_code(7);
    fprintf(stderr, (const char *)v2);
  }
  return *MK_FP(__GS__, 20) ^ v25;
}
// 804E158: using guessed type int debug;

//----- (0804BCA5) --------------------------------------------------------
time_t cleanup_frag_state_table()
{
  time_t v0; // edx@1
  time_t result; // eax@1
  time_t v2; // ebx@3
  struct_frag *v3; // ST1C_4@4
  struct_frag *v4; // [sp+18h] [bp-10h]@2

  v0 = time(0) - 1;
  result = time2;
  if ( v0 > time2 )
  {
    v4 = fragments_list;
    while ( v4 )
    {
      v2 = v4->time;
      if ( v2 >= time(0) - 5 )
      {
        v4 = v4->next;
      }
      else
      {
        v3 = v4->next;
        free(v4->frag_data);
        remove_from_frag_state_table(v4);
        v4 = v3;
      }
    }
    result = time(0);
    time2 = result;
  }
  return result;
}
// 804E164: using guessed type int time2;

//----- (0804BD3B) --------------------------------------------------------
int main_loop()
{
  char **v0; // eax@4
  uint16_t v1; // ax@6
  int v2; // ebx@8
  int v3; // ebx@8
  char **v4; // eax@8
  char **v5; // eax@12
  int v7; // [sp+Ch] [bp-61Ch]@22
  socklen_t addr_len; // [sp+20h] [bp-608h]@1
  int size; // [sp+24h] [bp-604h]@2
  ip6_hdr *pktptr; // [sp+28h] [bp-600h]@6
  int v11; // [sp+2Ch] [bp-5FCh]@8
  char pkt[1500]; // [sp+30h] [bp-5F8h]@1
  struct sockaddr addr; // [sp+60Ch] [bp-1Ch]@15
  int v14; // [sp+61Ch] [bp-Ch]@1

  v14 = *MK_FP(__GS__, 20);
  addr_len = 16;
  memset(pkt, 0, sizeof(pkt));
  while ( 1 )
  {
    size = recvfrom(fd, pkt, 1500u, 0, &addr, &addr_len);
    if ( size <= 0 )
      break;
    cleanup_frag_state_table();
    if ( size > 39 )
    {
      pktptr = (ip6_hdr *)pkt;
      v1 = ntohs(*(uint16_t *)&pkt[4]);
      if ( v1 + 40 == size )
      {
        if ( !memcmp(ipv6addr, &pktptr->ip6_dst, 0x10u) )
        {
          if ( pktptr->ip6_un1_nxt == IPPROTO_FRAGMENT )
          {
            hande_fragment((ip6_frag_packet_with_data *)pkt, size, (int)&addr);
          }
          else if ( pktptr->ip6_un1_nxt == IPPROTO_UDP )
          {
            if ( size > 48 )
              check_for_percent_n((int)&pkt[48], size - 48);
            udp_state_machine((udp_ip63 *)pkt, &addr);
          }
          else
          {
            printf("Invalid protocol: %d\n", pktptr->ip6_un1_nxt);
          }
          memset(pkt, 0, sizeof(pkt));
        }
        else
        {
          if ( debug )
          {
            v5 = lookup_error_code(16);
            fprintf(stderr, (const char *)v5);
          }
          memset(pkt, 0, sizeof(pkt));
        }
      }
      else
      {
        if ( debug )
        {
          v2 = 4 * ((*(_BYTE *)v11 & 0xF) + 10);
          v3 = ntohs(pktptr->ip6_un1_plen) + v2;
          v4 = lookup_error_code(15);
          fprintf(stderr, (const char *)v4, size, v3);
        }
        memset(pkt, 0, sizeof(pkt));
      }
    }
    else
    {
      if ( debug )
      {
        v0 = lookup_error_code(14);             // invalid packet length 548 (88) for ipv6 payload
        fprintf(stderr, (const char *)v0, size, v7);
      }
      memset(pkt, 0, sizeof(pkt));
    }
  }
  return *MK_FP(__GS__, 20) ^ v14;
}
// 804BD3B: using guessed type int main_loop(void);
// 804E158: using guessed type int debug;

//----- (0804C00F) --------------------------------------------------------
size_t __cdecl main(int a1, char **a2)
{
  size_t result; // eax@8
  int v3; // edx@10
  int v4; // [sp+66Ch] [bp-10h]@1

  v4 = *MK_FP(__GS__, 20);
  state_table_head = 0;
  fragments_list = 0;
  fd = 0;
  short0 = 0;
  time1 = time(0);
  time2 = time(0);
  srand(1u);
  signal(SIGCHLD, (__sighandler_t)1);
  signal(SIGPIPE, (__sighandler_t)1);
  if ( a1 == 2 )
    open_raw_socket_maybe((int)"eth0", a2[1]);
  else
    open_raw_socket_maybe((int)"eth0", 0);
  if ( debug )
    fprintf(
      stderr,
      "My addr: %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
      ipv6addr[0],
      ipv6addr[1],
      ipv6addr[2],
      ipv6addr[3],
      ipv6addr[4],
      ipv6addr[5],
      ipv6addr[6],
      ipv6addr[7],
      ipv6addr[8],
      ipv6addr[9],
      ipv6addr[10],
      ipv6addr[11],
      ipv6addr[12],
      ipv6addr[13],
      ipv6addr[14],
      ipv6addr[15]);
  if ( open_socket() )
    exit(-1);
  drop_privs("turdedo");
  main_loop();
  result = debug;
  if ( debug )
    result = fwrite("done...byebye\n", 1u, 0xEu, stderr);
  v3 = *MK_FP(__GS__, 20) ^ v4;
  return result;
}
// 804BD3B: using guessed type int main_loop(void);
// 804E158: using guessed type int debug;
// 804E164: using guessed type int time2;
// 804E168: using guessed type __int16 short0;
// 804E16C: using guessed type int time1;

//----- (0804C2E0) --------------------------------------------------------
int *__cdecl sub_804C2E0(int a1, int a2, int a3)
{
  init_proc();
  return &dword_804DF14;
}
// 80489A8: using guessed type int init_proc(void);
// 804DF14: using guessed type int dword_804DF14;

//----- (0804C352) --------------------------------------------------------
void sub_804C352()
{
  ;
}

//----- (0804C360) --------------------------------------------------------
int sub_804C360()
{
  int result; // eax@1
  int *v1; // ebx@2

  result = dword_804DF14;
  if ( dword_804DF14 != -1 )
  {
    v1 = &dword_804DF14;
    do
    {
      --v1;
      ((void (*)(void))result)();
      result = *v1;
    }
    while ( *v1 != -1 );
  }
  return result;
}
// 804DF14: using guessed type int dword_804DF14;

//----- (0804C38C) --------------------------------------------------------
void term_proc()
{
  sub_8048D90();
}

#error "There were 1 decompilation failure(s) on 29 function(s)"
